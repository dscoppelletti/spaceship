/*
 * Copyright (C) 2016-2018 Dario Scoppelletti, <http://www.scoppelletti.it/>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.Collections
import org.gradle.api.plugins.BasePlugin
import org.gradle.api.plugins.JavaBasePlugin

apply plugin: 'maven'
apply plugin: 'org.jetbrains.dokka-android'

class LibraryPlugin implements Plugin<Project> {
    static final String PROP_DEVREPOURL = 'it.scoppelletti.tools.devRepoUrl'
    
    void apply(Project project) {
        def devRepoUrl = null
        if (project.hasProperty(PROP_DEVREPOURL)) {
            devRepoUrl = project.property(PROP_DEVREPOURL)
            project.logger.info('Property {}={}', PROP_DEVREPOURL, devRepoUrl)
        } else {
            project.logger.info('Property {} not set', PROP_DEVREPOURL)
        }
        
        def androidExt = project.android
        def libExt = project.extensions.create('spaceship', LibraryExtension,
            project, androidExt)
        
        androidExt.libraryVariants.all({ variant ->
            def tools = new LibraryTools(project, variant, androidExt, libExt)
            tools.generateMetainf()
            tools.generateKdoc()
            tools.packageSources()
            tools.packageKdoc()
            
            if (devRepoUrl) {
                tools.artifacts()
                tools.upload(devRepoUrl)
            }
        })
        
        project.afterEvaluate({ prj ->
            // http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.PackagingOptions.html
            androidExt.packagingOptions.excludes -=
                [ '/META-INF/LICENSE.txt', '/META-INF/NOTICE.txt' ]
        })
    }
}

class Developer {
    String name = 'Dario Scoppelletti'
    String email = 'dario@scoppelletti.it'
    String url = 'http://www.scoppelletti.it'
}

class LibraryExtension {
    final Project project
    final Object androidExt
    final Developer developer
    String url = 'http://github.com/dscoppelletti/spaceship'
    String scmUrl = 'git@github.com:dscoppelletti/spaceship.git'
    String copyright
    
    LibraryExtension(Project project, Object androidExt) {
        this.project = project
        this.androidExt = androidExt
        this.developer = new Developer()
    }
    
    String getDescription() {
        if (project.description) {
            return project.description
        }
        
        return project.name
    }
    
    String getVersion() {
        def ver = androidExt.defaultConfig.versionName
        if (ver) {
            return ver
        }
        
        return project.version.toString()
    }
    
    String getCopyrightNotice() {
        return "${copyright} ${developer.name}, <a href=\"${developer.url}\" " +
            "target=\"_top\">${developer.url}</a>"
    }
}

class LibraryTaskNames {
    final String generateKdoc
    final String generateMetainf
    final String generateSources
    final String packageKdoc
    final String packageLibrary
    final String packageSources
    final String transformJavaRes
    final String upload
    
    LibraryTaskNames(Object variant) {
        def varName = variant.name.capitalize()
        
        this.generateKdoc = "generate${varName}Kdoc"
        this.generateMetainf = "generate${varName}Metainf"
        this.generateSources = "generate${varName}Sources"
        this.packageKdoc = "package${varName}Kdoc"
        this.packageLibrary = "bundle${varName}"
        this.packageSources = "package${varName}Sources"
        this.transformJavaRes =
            "transformResourcesWithMergeJavaResFor${varName}"
        this.upload = "upload${varName}"
    }
}

class LibraryTools {
    static final String CLASSIFIER_JAVADOC = 'javadoc'
    static final String CLASSIFIER_SOURCES = 'sources'
    final Project project
    final Object variant
    final Object androidExt
    final LibraryExtension libExt
    final LibraryTaskNames taskNames
    
    LibraryTools(Project project, Object variant, Object androidExt,
            LibraryExtension libExt)
    {
        this.project = project
        this.variant = variant
        this.androidExt = androidExt
        this.libExt = libExt
        this.taskNames = new LibraryTaskNames(variant)
    }
    
    void generateMetainf() {
        def metainfTask = project.task(taskNames.generateMetainf, type: Copy,
                overwrite: true, group: BasePlugin.BUILD_GROUP) {
            description "Generate META-INF for ${variant.name}."
            into project.file("${project.buildDir}/intermediates/" +
                "sourceFolderJavaResources/${variant.name}/META-INF")
            from project.file("${project.rootDir}/..")
            include 'LICENSE'
            rename 'LICENSE', 'LICENSE.txt'
            
            doLast {
                def f = project.file("${destinationDir}/NOTICE.txt")
                f.text = "${libExt.description}\n" +
                    "Copyright(C) ${libExt.copyright} " +
                    "${libExt.developer.name}, " +
                    "<${libExt.developer.url}/>\n"
            }
        }
        
        // http://stackoverflow.com/questions/34306200 - December 16, 2015
        def transformJavaResTask = project.tasks[taskNames.transformJavaRes]
        transformJavaResTask.dependsOn(metainfTask)    
    }
    
    void generateKdoc() {
        // - Dokka 0.9.16
        // The name of the class implmenenting the task is
        // "org.jetbrains.dokka.gradle.DokkaAndroidTask_Decorated"!
        def dokkaTask = project.tasks['dokka']
        def kdocTask = project.task(taskNames.generateKdoc,
                type: dokkaTask.getClass(), overwrite: true,
                group: JavaBasePlugin.DOCUMENTATION_GROUP) {
            description "Generate KDoc for ${variant.name}."
            
            // http://github.com/Kotlin/dokka, README.md
            moduleName = project.archivesBaseName
            outputFormat = 'html'
            outputDirectory = "${project.buildDir}/docs/kdoc"
            includes = [ project.file("${project.rootDir}/README.md") ]
            jdkVersion = 8 // "${androidExt.compileOptions.sourceCompatibility}"
            cacheRoot = 'default'
            includeNonPublic = false
            skipDeprecated = true
            reportUndocumented = false
            skipEmptyPackages = true
            // impliedPlatforms = [ 'JVM' ]
            // classpath = 
            // sourceDirs =
            noStdlibLink = true
        }
          
        kdocTask.dependsOn(taskNames.packageLibrary)
    }
    
    void packageSources() {    
        def jarTask = project.task(taskNames.packageSources, type: Jar,
                overwrite: true, group: BasePlugin.UPLOAD_GROUP) {
            description "Packages sources for ${variant.name}."
            
            def source = project.files()
            variant.sourceSets.each { sourceSet ->
                sourceSet.java.srcDirs.each { f ->
                    source = source.plus(f)
                }
            }
            
            classifier CLASSIFIER_SOURCES
            from source
            
            def metainfTask = project.tasks[taskNames.generateMetainf]
            metaInf {
                from metainfTask.destinationDir
            }
        }
        
        jarTask.dependsOn(taskNames.generateSources)
    }
    
    void packageKdoc() {
        def kdocTask = project.tasks[taskNames.generateKdoc]
        def jarTask = project.task(taskNames.packageKdoc, type: Jar,
                overwrite: true, group: BasePlugin.UPLOAD_GROUP) {
            description "Packages KDoc for ${variant.name}."
            
            def compiler = variant.javaCompiler
            
            classifier CLASSIFIER_JAVADOC
            from kdocTask.outputDirectory
        }
    
        jarTask.dependsOn(kdocTask)
    }
    
    void upload(String devRepoUrl) {
        // - Android Plugin for Gradle 2.1.0
    	// The Android plug-in overloads the install task and remaps it to, for
    	// example, "installDebugAndroidTest"; such tasks try to install the App
    	// into a connected device.
    	// I have to define my install task, thus I define one task for each
    	// variant.
    	//
    	// - Gradle 2.10
    	// I would like to install in local Maven repository, but the pom.xml
        // file doesn't include the dependencies, thus I deploy in a development
        // Maven repository (anyway usually in local disk).
        
        def uploadTask = project.task(taskNames.upload, type: Upload,
                overwrite: true, group: BasePlugin.UPLOAD_GROUP) {
            description "Installs the ${variant.name} artifacts into the " +
				"development Maven repository."
                
            configuration = project.configurations[variant.name]
            repositories.mavenDeployer {
				pom.project {
					version libExt.version
					description libExt.description
					url libExt.url
					inceptionYear libExt.copyright
					developers {
						developer {
							name libExt.developer.name
							email libExt.developer.email
							url libExt.developer.url
						}
					}
                    licenses {
                        license {
                            name 'The Apache License, Version 2.0'
                            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                        }
                    }
                    scm {
                         connection "scm:git:${libExt.scmUrl}"
                         developerConnection "scm:git:${libExt.scmUrl}"
                         url libExt.scmUrl
                    }                   
				}
				repository(url: devRepoUrl)
			}
        }
    }
    
    void artifacts() {
        def cfgName = variant.name
        project.configurations.maybeCreate(cfgName)
        
        project.artifacts.add(cfgName, project.tasks[taskNames.packageLibrary])
        project.artifacts.add(cfgName, project.tasks[taskNames.packageSources])
        project.artifacts.add(cfgName, project.tasks[taskNames.packageKdoc])
    }
}

// - Gradle User Guide, ver 4.4
// The plugin is not visible outside the build script
apply plugin: LibraryPlugin

