/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * - Dario Scoppelletti, 2018
 * Repository: http://android.googlesource.com/platform/frameworks/base
 * File: master/keystore/java/android/security/keystore/AndroidKeyStoreSpi.java
 * Commit: b631503200c8de47bbd83a71f17c798f5c2f1582 - March 15, 2018
 * Based on method toCertificate of the class AndroidKeyStoreSpi.
 * The certificate generated by Bouncy Castle (see FakeCertificateFactory class)
 * does not fit in a KeyStore.PrivateKeyEntry object, so I have to encode it as
 * a byte array and then rebuild it as a pure Java certificate.
 */

package it.scoppelletti.spaceship.security;

import java.io.ByteArrayInputStream;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;

public final class CertificateNormalizer {
    private static final String CERT_TYPE = "X509";

    private CertificateNormalizer() {
    }

    public static Certificate toCertificate(byte[] bytes) throws
            CertificateException {
        CertificateFactory certFactory;

        certFactory = CertificateFactory.getInstance(
                CertificateNormalizer.CERT_TYPE);
        return certFactory.generateCertificate(new ByteArrayInputStream(bytes));
    }
}
